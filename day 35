#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int minDays(vector<int>& bloom_days, int m, int k) {
        // Early exit: if we cannot make the required bouquets, return -1
        if (m * k > bloom_days.size()) return -1;
        
        // Helper function to check if it's possible to make m bouquets by day 'day'
        auto is_valid = [&](int day) -> bool {
            int cur_bloom = 0;     // Current count of consecutive bloomed flowers
            int cur_bouquets = 0;  // Current count of bouquets made
            
            for (int i = 0; i < bloom_days.size(); ++i) {
                if (bloom_days[i] <= day) {
                    // Flower has bloomed by 'day'
                    cur_bloom++;
                    if (cur_bloom == k) {
                        // If we've collected k flowers, we can make a bouquet
                        cur_bloom = 0;
                        cur_bouquets++;
                        if (cur_bouquets >= m) return true;
                    }
                } else {
                    // Flower has not bloomed by 'day', reset consecutive count
                    cur_bloom = 0;
                }
            }
            return false;
        };

        // Binary search over the range of days
        int left = *min_element(bloom_days.begin(), bloom_days.end());
        int right = *max_element(bloom_days.begin(), bloom_days.end());
        int optimal_day = right;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (is_valid(mid)) {
                optimal_day = mid;  // If valid, try for an earlier day
                right = mid - 1;
            } else {
                left = mid + 1;  // If not valid, try for a later day
            }
        }
        
        return optimal_day;
    }
};
