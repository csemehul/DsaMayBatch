
Input: `nums = [1, 2, 1, 3, 2, 5]`

 Steps:

1. **Find XOR of All Elements**:
   ```cpp
   int xorSum = 0;
   for (int num : nums) {
       xorSum ^= num;
   }
   ```
   - Iteration 1: xorSum = 0 ^ 1 = 1
   - Iteration 2: xorSum = 1 ^ 2 = 3
   - Iteration 3: xorSum = 3 ^ 1 = 2
   - Iteration 4: xorSum = 2 ^ 3 = 1
   - Iteration 5: xorSum = 1 ^ 2 = 3
   - Iteration 6: xorSum = 3 ^ 5 = 6

   Result: `xorSum = 6` (which is `0110` in binary)

2. **Find Rightmost Set Bit**:
   ```cpp
   int rightmostSetBit = xorSum & (-xorSum);
   ```
   - `xorSum = 6` (binary `0110`)
   - `-xorSum = -6` (binary `...11111111111111111111111111111010`, two's complement)
   - `rightmostSetBit = 6 & -6 = 2` (binary `0010`)

   Result: `rightmostSetBit = 2`

3. **Divide Numbers into Two Groups and XOR Separately**:
   ```cpp
   int num1 = 0, num2 = 0;
   for (int num : nums) {
       if (num & rightmostSetBit) {
           num1 ^= num;
       } else {
           num2 ^= num;
       }
   }
   ```
   - Iteration 1: `num = 1`, `1 & 2 = 0`, `num2 = 0 ^ 1 = 1`
   - Iteration 2: `num = 2`, `2 & 2 = 2`, `num1 = 0 ^ 2 = 2`
   - Iteration 3: `num = 1`, `1 & 2 = 0`, `num2 = 1 ^ 1 = 0`
   - Iteration 4: `num = 3`, `3 & 2 = 2`, `num1 = 2 ^ 3 = 1`
   - Iteration 5: `num = 2`, `2 & 2 = 2`, `num1 = 1 ^ 2 = 3`
   - Iteration 6: `num = 5`, `5 & 2 = 0`, `num2 = 0 ^ 5 = 5`

   Result: `num1 = 3`, `num2 = 5`

### Result
The two unique numbers are `[3, 5]`.

### Summary
- `xorSum` is calculated as 6.
- The rightmost set bit in `xorSum` is found to be 2.
- Numbers are divided into two groups based on this set bit and XORed separately to get the unique numbers `3` and `5`.

This dry run demonstrates how the optimized solution effectively finds the two unique numbers in linear time.
